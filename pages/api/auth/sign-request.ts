import jwt from 'jsonwebtoken';
import { NextApiResponse } from 'next';
import errorHandler from '../../../middlewares/error-handler';
import rateLimit from '../../../middlewares/rate-limit';
import { NextApiRequestWithLog } from '../../../types/moveo';
import {
  AppError,
  ForbiddenError,
  MethodNotAllowed,
} from '../../../util/errors';

export type SignTokenResponse =
  | {
    token: string;
  }
  | {
    code: number;
    error: string;
  };

const limiter = rateLimit({
  interval: 60 * 1000, // 60 seconds
  uniqueTokenPerInterval: 500, // Max 500 users per second
  limit: 20, // Max requests in window
});
const { sign } = jwt;

/**
 * PRIVATE_RSA_KEYS keys have the format costumerID: <RSA KEY ENV. VAR NAME>
 */
export const PRIVATE_RSA_KEYS = {
  demo: process.env.PRIVATE_PISTI_RSA_KEY,
  109005231568317: process.env.PRIVATE_PISTI_RSA_KEY,
};

/**
 * Returns a signed JWT generated by RS256 algorithm.
 */
export function signJWT(sender_id: string, secret: string) {
  const payload = {
    sub: sender_id, // Required
    iss: 'www.webviews.moveo.ai', // Required
  };

  // The "expiresIn" option adds an "exp" claim to the payload.
  return sign(payload, secret, { algorithm: 'RS256', expiresIn: '4000ms' });
}

const VECEL_HOST = 'vercel.app';
const MOVEO_HOST = 'moveo.ai';

/**
 * Signs request by producing JWT token use as Auth in Moveo Integrations
 */
const handler = async (
  req: NextApiRequestWithLog,
  res: NextApiResponse<SignTokenResponse>
) => {
  if (req.method !== 'GET') {
    throw new MethodNotAllowed(req.method);
  }

  // if referer is false-like or it doesnt include any of the allowed domains
  if (
    !req.headers.referer ||
    (!req.headers.referer.includes(VECEL_HOST) &&
      !req.headers.referer.includes(MOVEO_HOST))
  ) {
    req.log.warn(
      'Received request from unauthorized origin: ',
      req.headers.referer
    );
    throw new ForbiddenError();
  }

  // 20 requests per minute
  limiter.check(req, res);

  const sender_id = req.query?.sender_id as string;
  const customer_id = req.query?.customer_id as string;
  if (!sender_id || !customer_id) {
    req.log.warn(
      `Expected required sender_id, customer_id, channel but found ${JSON.stringify(
        req.query
      )}`
    );
    throw new AppError(
      'Missing required parameter: sender_id or customer_id.',
      400
    );
  }
  if (!PRIVATE_RSA_KEYS[customer_id]) {
    req.log.warn(`customer_id ${customer_id} not in known RSA key map`);
    throw new AppError('Bad request: Wrong customer_id', 400);
  }

  const secret = Buffer.from(
    PRIVATE_RSA_KEYS[`${customer_id}`],
    'base64'
  ).toString();

  const signedRequest = signJWT(sender_id, secret);
  return res.json({ token: signedRequest });
};

export default errorHandler(handler);
